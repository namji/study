# 1장. 변수


### 1. 메모리 미리보기

컴퓨터는 0과 1로 이루어진 데이터를 처리한다. 0과 1을 표현할 수 있는 데이터 단위를 비트라고 부른다. 
비트가 8개모이면 바이트라고 부른다 1바이트는 01011010과 같이 0과 1이 총 8개로 이루어져있다.

Bit  
Byte = 8 Bit  
KByte = 1024 Byte  
MByte = 1024 KByte  
GByte = 1024 MByte  
TByte = 1024 GByte  
  
 
#### 1.1 32비트와 64비트의 의미  
컴퓨터는 데이터 단위로 비트를 사용한다. 데이터를 한번에 몇 개 보낼 수 있는지 나타내는 지표가 32비트와 64비트이다.
비트 수가 높을 수록 한 번에 보낼 수 있는 데이터 양이 많아진다. 또한 32비트 컴퓨터는 메모리 주소를 32비트로 표현하고 64비트 컴퓨터는 64비트로 표현한다.


#### 1.2 메모리 주소
32비트 컴퓨터라면 주소하나를 나타내는데 2진수 32자릿수를 사용한다. 그러므로 32비트에서 나타낼 수 있는 주소 갯수는 2의 32승(=4,294,967,296)개다.
메모리 주소 1개는 1바이트이므로 32비트로는 2의 32승 바이트를 표현할 수 있다. 이는 4GB이다. 그래서 32비트 컴퓨터를 사면 메모리를 추가로 사용해도 4GB까지밖에 사용할 수 없다.


### 2. 변수의 의미
변수란 데이터를 저장할 수 있는 메모리공간 그 자체를 뜻한다. 변수에는 숫자와 문자, 객체, 함수까지도 담을 수 있으며 값이나 가리키는 대상은 언제든 변경될 수 있다.
<pre><code>
int num = 5;           num[5]
</code></pre>

### 3. 파이썬에서의 변수: 이름과 값 객체
파이썬에서 변수라는 의미는 다른 언어와 다르다. 변수가 저장공간 그 자체가 아니라 그냥 이름만을 의미한다. 파이썬에서 쓰는 변수는 이름과 값으로 나뉘어진다. 
<pre><code>
num = 5           num--->[5]
</code></pre>




# 2장. 정수


### 1. 컴퓨터에서 수를 표현하는 방법

#### 1.1 10진수
수를 표현하는 데 총 10개의 숫자를 사용 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  

#### 1.2 2진수 
수를 표현하는 데 0과 1만 사용  

#### 1.3 16진수
수를 표현하는 데 총 열여섯개의 숫자 사용 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 + a, b, c, d, e, f  

### 2. 10진수를 2진수로 
ex) 25 / 2 = 12 ... 1  
    12 / 2 =  6 ... 0  
     6 / 2 =  3 ... 0  
     3 / 2 =  1 ... 1  
     => 11001
     
ex) 25 = 2**3 + 2**2 + 2**0
     => 11001
     
ex) >>> bin(25)  => 11001


### 3. 2진수를 10진수로

ex) 11001  
 => 1 * 2**4  +  1 * 2**3  +  0 * 2**2  +  0 * 2**1  + 0 * 2**0  
 => 16 + 8 + 0 + 0 + 1  
 => 25  

### 4. 16진수를 2진수로
16진수 -> 10진수 -> 2진수
F     -> 15    -> 1111


### 5. 코딩으로 확인하는 진수변환 
<pre><code>
>>> a = 0xa
>>> bin(a)
>>> '0b1010'
</code></pre>

<pre><code>
>>> hex(0b00101101)
>>> '0x2d'
</code></pre>

### 6. 양의 정수
컴퓨터는 정수를 다양한 크기로 저장할 수 있다. 정수가 1바이트라고 가정하고 설명하면 양수와 음수 부호를 나타내는데 1비트를 사용한다. 
맨 앞의 비트가 0이면 양수, 1이면 음수다. 그리고 나머지 7개의 비트로 숫자를 표현한다. 


### 7. 음의 정수

#### 7.1 보수 개념
보수란 보충해 주는 수이다. 10진수에서는 10의 보수법과 9의 보수법이 존재한다. 7에대한 10의 보수는 7과 어떤 수를 더헀을 때 10이 되는지 계산한 수 3이다.
7에 대한 9의 보수는 2이므로 10의 보수는 9의 보수 +1 과 같다고 볼 수 있다. 

#### 7.2 2의 보수
이런 개념을 2진법에도 반영하여 음의 정수 개념을 2의 보수로 표현할 수 있다. 2진법의 보수에는 1의 보수와 2의 보수가 있다. 2의 보수를 구할 떄는 
보충설명 : http://zapiro.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84%EB%B2%95%EB%B3%B4%EC%88%98%EB%B2%95


#### 7.3 음수의 표현 
-4 ==2진수==> 0000 0100 ==1의보수==> 1111 1011 ==+1==> 1111 1100


#### 7.4 2의 보수로 표현하는 이유
- 양수와 음수를 같은 체계로 만들면 +0, -0 으로 0이 두개가 존재하게 된다. 이렇게 되면 낭비이고 두 수의 뺄셈을 할 때 +0과 -0을 비교하면 결과가 다르게 나올 수 있다 
- 컴퓨터에서 뺄셈을 할 때, 2의 보수 개념을 활용한다. 9-4 을 빼는 것이 아니라 실제로는 9+(-4)을 하게된다. 이를 실제 계산으로 해보면
 0000 1001 + 1111 1100 = 10000 0101 이 나오는데 앞의 1은 지워준다. 



# 4장. 문자열

### 1. 아스키코드
문자인코딩은 문자집합을 메모리에 저장하거나 통신하는데 사용하기 위해 부호화 하는 방식이다. 컴퓨터에 인식 시키려면 문자를 2진수로 나타내야하기 때문이다. 
아스키코드는 대표적인 문자인코딩 방식으로 비트 일곱개로 총 128개의 문자를 표현한다.

### 2. 유니코드
아스키 코드는 알파벳을 표현하는데에만 적합하기 때문에 한글이나 기타 언어를 표현하기위해서 유니코드가 쓰인다. 7비트에서 16비트까지 확장해 65,536개 문자를 표현할 수 있고 더 확장도 가능하다.



### 3. 유니코드 인코딩 방식
문자수가 많아질 것을 대비하여 크게는 크기별로 utf8, utf16, utf32로 나뉘었다. 

#### 3.1 UTF-8
유니코드 문자 하나를 1바이트에서 4바이트 사이에서 표현하는 방식. 문자에 따라서 바이트수가 달라지므로 가변길이 인코딩 방식이다. 
문자열 "가" 는 유니코드의 코드포인트로 AC00이다. utf8에서 0800~FFFF사이의 문자는 다음과 같은 포맷으로 변경된다.
<pre><code>
1110XXXX 10XXXXXX 10XXXXXX
</code></pre>
앞의 3자리는 사용바이트수를 나타내며 X로 표현된 부분에는 AC00을 2진수로 변환한 후 차례대로 채운다. 
AC00을 2진수로 변환하면 1010 1100 0000 0000 이며 순서대로 채우면 아래와 같다.
<pre><code>
11101010 10110000 10000000
</code></pre>
이 결과를 16진수로 다시 변환하면 3바이트 결과값인 0xEAB080이 된다.


#### 3.2 UTF-16
2바이트, 4바이트 단위로 문자를 표현한다. 코드 유닛의 크기는 16비트이다. 유니코드 값은 유니코드의 코드포인트 값을 순서만 바꾼 모습이다.
<pre><code>
"가" -> AC00 -> 00 AC
</code></pre>

#### 3.3 UTF-32
모든 문자를 4바이트로 표현한다. 코드유닛의 크기는 32비트이다. 
<pre><code>
"가" -> AC00 -> 00 AC 00 00
</code></pre>


### 4. 파이썬 문자열의 특징
C언어에서는 문자열을 변수로 만들면 문자를 변경할 수 있고 상수로 만들면 변경할 수 없지만, 파이썬에서는 무조건 문자열을 변경할 수 없다.
더하거나 고쳐도 새로 메모리에 할당되는 형식이지 원래 있던 값이 변경되지 않는다. 



# 5장. 함수

### 1. 함수를 시작하기 전에 

#### 1.1 자료구조
- 스택 : 데이터를 접시처럼 차곡차곡 쌓아올리고, 사용할 때는 맨위부터 차례차례 꺼내는 구조. 마지막에 들어온 데이터가 가장 먼저 나가게 된다.


#### 1.2 전역변수와 지역변수
- 전역변수 : 전체 영역에서 접근할 수 있는 변수. 함수안에서도 접근할 수 있다.
<pre><code>
g_var = 10

def func():
	print(g_var)
</code></pre>

함수 안에서 전역변수 변경은 불가능 하다
<pre><code>
g_var = 10

def func():
	g_var = 20
	print(g_var)
print(g_var)
</code></pre>
><pre>20<code>
</code>10</pre>


# 6장 객체지향 프로그래밍

### 4. 객체지향 프로그래밍
이 프로그램이 무슨일을 하는가에 대한 대답을 알려준 절차지향과 달리 객체지향은 __현실에 존재하는 객체를 어떻게 모델링할 것인가__에 대한 물음에서 시작한다. 

#### 4.1 캡슐화
모든사람이 키, 나이, 몸무게, 성별과 같은 특성을 가지고있지만 그 값은 저마다 다르다. 이런 특성값 하나하나가 모여 나라는 객체를 만든다.
또한 사람은 잠자기, 숨쉬기, 말하기 같은 행동을 할수도 있다. 이처럼 객체는 고유의 특성값과 행동, 기능으로 표현할 수 있다. 
이것을 프로그래밍으로 정리하면 특성들은 변수가 되고, 행동과 기능은 함수이다. 이렇게 현실세계를 모델링할 때 변수와 함수를 가진 객체를 이용하는 
패러다임을 객체지향이라고 하며, 변수와 함수를 하나의 단위로 묶는 것을 __캡슐화__라고 한다.

#### 4.2 클래스를 사용해 객체 만들기
컴퓨터에게 객체라는 메모리공간을 할당해서 객체 안 변수들을 초기하하고 함수를 호출하는데 필요한 것이 바로 클래스다.
클래스는 객체를 생성해내는 템플릿이고, 객체는 클래스를 이용해 만들어지니 변수와 함수를 지닌 메모리공간이다.
객체와 유사한 개념으로 인스턴스가 있다. 객체는 객체 자체에 초점을 맞춤 용어고, 인스턴스는 이 객체가 어떤 클래스에서 만들어졌는지에 초점을 맞춘 용어이다. 
ex) 이 객체는 Person 클래스의 인스턴스이다

- 클래스의 첫글자는 대문자로 하는 것이 관례이다.
- 클래스 내부의 변수를 __프로퍼티__, __멤버 변수__ 라고 부른다.
- <code> __init()__ </code> 함수는 인스턴스의 멤버변수를 초기화하는 특별한 역할을 하는 __생성자__라고 부르는 함수이다.
- 파이썬에서 앞뒤로 언더바 두개가 있는 팜수는 예약해두었다는 의미이다. 
- self 키워드는 객체 자신을 의미한다.
- 클래스에 있는 함수를 멤버함수, 메서드라고 부른다.
- 멤버변수와 멤버함수를 모두 속성(attribute)라고 부른다.

#### 4.3 파이썬의 클래스

- 함수와 메서드의 차이
<pre><code>
>>> type(Person.give_money)
<class 'function'>
>>> type(g.give_money)
<class 'method'>
</code></pre>

클래스의 함수는 class function, 인스턴스의 함수는 class method로 나온다.

<pre><code>
>>>dir(g.give_money)
['__self__', '__class__', '__func__', ...]
</code></pre>
give_money() 메서드의 속성에 이미 self 가 있기 때문에 사용할 때 self를 전달하지않아도된다.
<code>__func__</code>를 확인해보면 Person class의 함수라고 나온다. 

- 인스턴스 메서드와 클래스 메서드
<pre><code>
Class A:
  c_mem = 10  -> 클래스 멤버변수
  
  @classmethod -> 클래스 메서드로 만들어주는 데코레이터
  def cls_f(cls):
    print(cls.c_mem)
    
  def __init__(self, num):
    self.i_mem = num -> 인스턴스 멤버선언
    
  def ins_f(self):
    print(self.c_mem)
</code></pre>
객체가 멤버와 메서드를 가질 수 있는 것처럼 클래스도 멤버와 메서드를 가질 수 있다. 이를 각각 클래스멤버변수, 클래스 메서드라고한다.
클래스 멤버는 객체가 없어도 클래스를 통해서 바로 변수와 메서드에 접근가능하다. 인스턴스 메서드는 객체가 첫번째인자로 전달할 객체가 없기 때문에 호출할 수 없다. 
ex) A.c_mem, A.cls_f()

- 클래스 메서드와 정적 메서드 
<pre><code>
Class A:
  @staticmethod -> 정적 메서드
  def f():
    print('static method')
  
  @classmethod -> 클래스 메서드
  def g(cls):
    print('class method')
</code></pre>
정적 메서드는 인자로 클래스나 객체를 받지 않는다. 함수의 정의만 클래스 안에 있을 뿐 일반함수와 같으며 전역함수를 대체할 수도 있다.
클래스 메서드는 첫번째 인자로 클래스를 받는다. 생성자를 대체해서 사용할 수도 있다.


#### 4.5 정보은닉
캡슐화 할 때, 어떤 멤버변수와 메서드는 공개하여 유저 프로그래머가 사용할 수 있게 하고, 어떤 것은 숨겨서 접근할 수 없도록 해야할 것 인지 정하는 개념을 정보은닉이라고 한다. 
캡슐화는 정보은닉을 포함한 개념이다. C++이나 자바언어는 멤버변수를 선언할 때 외부에서 접근할 수 없도록 만드는 기능이 있어서 정보은닉을 구현할 수 있다. (private 키워드)
그러나 파이썬은 기본적으로 정보은닉을 지원하지 않는다. 그래서 약간의 편법(?)을 사용해 정보은닉을 구현한다.

- 숨기려는 멤버 앞에 언더바 두 개 붙이기 

<pre><code>
Class Account:
  def __init__(self, name, money):
    self.user = name
    self.__balace = money
    
  def get_balance(self):
    return self.__balance
    
  def set_balance(self, money):
    self.__balance = money

account = Account('greg', 5000)
</code></pre>
이 방법은 마치 정보은닉이 된것 처럼보이지만 실제로는 아니다. 
> account.__dict__  
> {'user': 'greg', '_Account__balance': 5000, '_ _balance': -3000}  

account._ _balance 로 접근하여 값을 수정할 수 있기 때문이다. _Account__balance 필드는 유저가 직접 만들지 않았지만 
멤버변수 이름에 언더바 두개가 붙어있다면 '_클래스이름'이 앞에 붙게된다.(맹글링) 결과적으로 이 방법은 마음만 먹으면 얼마든지 접근하여 변경할 수 있다.

- 숨기려는 멤버 앞에 언더바 한 개 붙이기  

주로 모듈 내부에서만 사용하는 private 클래스/함수/변수/메서드를 선언할 때쓰는 컨벤션이다. 이 컨벤션으로 선언하게 되면 외부에서 모듈전체를 import할 시에 언더바로 시작하는것은
모두 import에서 무시된다. 그러나 이 방법도 직접 가져다쓰거나 호출할 경우에는 사용이 가능하다.

- 프로퍼티 기법 
<pre><code>
class Account:
  @property
  def balance(self):
    return self._balance
    
  @property.setter
  def balance(self, money):
    self._balance = money
  
</code></pre>
프로퍼티를 이용하면 멤버에 접근하는 것 처럼 보이지만 사실은 메서드를 호출한다. 그러나 이방법도 유저프로그래머가 멤버변수로 바로 접근하는 것을 원천적으로 막을 수 없다.









